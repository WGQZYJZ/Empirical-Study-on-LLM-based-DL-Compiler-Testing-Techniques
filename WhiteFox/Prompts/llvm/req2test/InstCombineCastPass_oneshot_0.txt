### Please generate a valid C++ Code that meets the requirements below. The code should contain a `main` function. And the main function gives back an output value. Please initialize all the variables you define with a value. Please do not include any undefined behavior in your code. The code you generated will be used to test the correctness of the optimization.

# Description of requirements

The C++ code should contain the following pattern:
```
// no va_arg in stdarg.h is used

// define one function which has variable arguments
static int varargs_func(int x, ...) {
    RANDOM_CODE; // Do something here with input arguments, but don't generate the codes contain va_args
    int result = x OPERATOR ANY_VALUE; // result is related to x
    return result;
}

int main() {
    RANDOM_CODE;  // declare some variables
    int x = ANY_VALUE; // declare variable x
    ANY_TYPE y = ANY_VALUE; // declare y
    ANY_TYPE z = ANY_VALUE; // declare z
    // invoke the func varargs_func
    int result = varargs_func(x, y, z, ANY_VALUE, ANY_VALUE); // you can pass the arguments with any number, any type
    return result;
}
```
This pattern characterizes scenarios where within the `main` function, there exists a call to `varargs_func`, and the result of this call is being used. `varargs_func` is marked as variable function, which accepts variable arguments, then returns a single `ANY_TYPE` value that is determined by the first argument. The first argument can be any type, e.g. `int`, `float`, `ptr` `struct`, and so on. The functions must be `static`(which will be translated into ir function with internel attribute), no vastart intrinsic(such as `va_arg` in `stdarg.h`). The `main` function must return a value related to this optimization for further comparison.

# C++ Code begins 

```cpp
#include <vector>
#include <string>
#include <iostream>
#include <map>

int a, b, c, d, e, f, g, h, i;
int x;
long j;
static long *k = &j;
long *const l = &j;
int m() {
  if (b)
    return 1;
  if (c & a)
    return 1;
  return 0;
}

static int varargs_func(int x, ...) {
  f = 3;
  for (; f >= 0; f--) {
    e = 0;
    for (; e <= 3; e++) {
      d = 3;
      for (; d >= 0; d--) {
        g = 0;
        for (; g <= 3; g++) {
          i = 0;
          for (; i <= 3; i++)
            *l = m() + (int)*k + h + *k + x;
        }
      }
    }
  }
  return *l;
}

int main() { 
  std::vector<int> vec = {0, 1, 2, 3};
  for (int i = 0; i < vec.size(); i++) { // Avoid out-of-bound access
    vec[i] = i * 2;
  }
  x = 3;
  return varargs_func(x, a, b, c);
}
```

# C++ Code ends

### Please generate a valid C++ Code that meets the requirements below. The code should contain a `main` function. And the main function gives back an output value. Please initialize all the variables you define with a value. Please do not include any undefined behavior in your code. The code you generated will be used to test the correctness of the optimization.

# Description of requirements

The C++ code should contain the following pattern:

```cpp
int main() {
    ANY_TYPE x = ANY_VALUE; // declare variable x
    ANY_TYPE y = ANY_VALUE; // declare variable y
    // perform some operations on x and y
    ANY_TYPE result = x OPERATOR y; // result is related to x and y
    // truncate the result to a smaller type
    SMALLER_TYPE truncated_result = static_cast<SMALLER_TYPE>(result);
    return truncated_result;
}
```

This pattern characterizes scenarios where within the `main` function, there exists a computation involving variables `x` and `y` of any type (`ANY_TYPE`), and the result of this computation is being truncated to a smaller type (`SMALLER_TYPE`). The `main` function must return a value related to this optimization for further comparison. 

The `OPERATOR` can be any binary operator, such as `+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`, `<<`, `>>`, etc. The `ANY_TYPE` can be any type that supports the chosen operator, such as `int`, `float`, `double`, `long`, etc. The `SMALLER_TYPE` must be a type that is smaller than `ANY_TYPE`, such as `short` for `int`, `float` for `double`, etc. 

The `static_cast<SMALLER_TYPE>(result)` is the key part of the code that triggers the `InstCombineCastPass` optimization. This cast operation is translated into a `TruncInst` in LLVM IR, which is then optimized by the `InstCombineCastPass`.

# C++ Code begins
